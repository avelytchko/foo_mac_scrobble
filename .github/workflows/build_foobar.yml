name: Build and test foo_mac_scrobble

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - workflows/release.yml
      - workflows/update_toc.yml
  pull_request:
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - workflows/release.yml
      - workflows/update_toc.yml

jobs:
  build:
    runs-on: macos-latest

    env:
      FOOBAR2000_VERSION: "2.25.3"
      FOOBAR_WAIT_SECS: 120
      FOOBAR_LOG_STRINGS: 500
      FOOBAR_LOG_FILE: "foobar.log"
      FOOBAR_PLUGIN_ZIP_NAME: "foo_mac_scrobble_build.zip"

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Ensure Xcode is active
        run: |
          sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
          xcodebuild -version

      - name: Install build dependencies
        run: |
          sudo gem install xcpretty

      - name: Build plugin with Xcode
        working-directory: foobar2000/foo_mac_scrobble
        run: |
          echo "::group::üß© Xcode Build"
          mkdir -p build
          set -o pipefail
          xcodebuild -project foo_mac_scrobble.xcodeproj \
            -scheme foo_mac_scrobble \
            -configuration Release \
            -derivedDataPath build \
            OTHER_CPLUSPLUSFLAGS="-DFOO_LASTFM_DEBUG_DEFAULT=1 \
            -DFOO_LASTFM_CI_API_KEY='\"${{ secrets.LASTFM_API_KEY }}\"' \
            -DFOO_LASTFM_CI_API_SECRET='\"${{ secrets.LASTFM_API_SECRET }}\"'" \
            > build/build.log 2>&1 | xcpretty --color --simple
          echo "::endgroup::"

      - name: Censor secrets in build log
        run: |
          echo "::group::üîí Censor Secrets in Build Log"
          LOG_FILE="foobar2000/foo_mac_scrobble/build/build.log"
          if [ -f "$LOG_FILE" ]; then
            sed -i '' "s/${{ secrets.LASTFM_API_KEY }}/***API_KEY***/g" "$LOG_FILE"
            sed -i '' "s/${{ secrets.LASTFM_API_SECRET }}/***API_SECRET***/g" "$LOG_FILE"
            echo "‚úÖ Secrets censored in build.log"
          else
            echo "‚ùå Build log file not found!"
            exit 1
          fi
          echo "::endgroup::"

      - name: üìú Show full build log
        run: |
          echo "::group::üìú Full Build Log"
          LOG_FILE="foobar2000/foo_mac_scrobble/build/build.log"
          if [ -f "$LOG_FILE" ]; then
            cat "$LOG_FILE" | sed "s/$API_KEY/***API_KEY***/g" | sed "s/$API_SECRET/***API_SECRET***/g"
          else
            echo "‚ùå Build log file not found!"
            exit 1
          fi
          echo "::endgroup::"

      - name: üì¶ Show build output
        run: |
          echo "::group::üì¶ Build Artifacts"
          find foobar2000/foo_mac_scrobble/build -type d -name "*.component"
          echo "::endgroup::"

      - name: ‚ö†Ô∏è Check for build warnings
        run: |
          echo "::group::‚ö†Ô∏è Build Warnings"
          # Use log file from the original build
          LOG_FILE="foobar2000/foo_mac_scrobble/build/build.log"
          if [ -f "$LOG_FILE" ]; then
            WARNINGS=$(grep -i "warning:" "$LOG_FILE" || true)
            if [ -n "$WARNINGS" ]; then
              echo "Warnings found:"
              echo "$WARNINGS" | head -n 20
            else
              echo "‚úÖ No warnings detected."
            fi
          else
            echo "‚ùå Build log file not found!"
            exit 1
          fi
          echo "::endgroup::"

      # Download and install foobar2000 application
      - name: Download foobar2000 for macOS
        run: |
          wget -q -O foobar2000.dmg "https://www.foobar2000.org/downloads/foobar2000-v${FOOBAR2000_VERSION}.dmg"
          hdiutil attach foobar2000.dmg -mountpoint /Volumes/foobar2000
          sudo cp -R "/Volumes/foobar2000/foobar2000.app" /Applications/
          hdiutil detach /Volumes/foobar2000
          rm -f foobar2000.dmg

      # Install the built component into foobar2000's user-components directory
      - name: Install built component into foobar2000
        run: |
          COMPONENT_SRC=$(find foobar2000/foo_mac_scrobble/build -name "foo_mac_scrobble.component" | head -n 1)
          PLUGINS_DIR="$HOME/Library/foobar2000-v2/user-components/foo_mac_scrobble"
          mkdir -p "$PLUGINS_DIR"
          cp -r "$COMPONENT_SRC" "$PLUGINS_DIR/"
          echo "‚úÖ Installed to $PLUGINS_DIR"
          ls -la "$PLUGINS_DIR"

      # Prepare Last.fm session file with authenticated user credentials
      - name: Prepare Last.fm session
        run: |
          mkdir -p "$HOME/Library/foobar2000-v2"
          echo '${{ secrets.LASTFM_SESSION_JSON }}' > "$HOME/Library/foobar2000-v2/lastfm_session.json"
          echo "‚úÖ Session JSON written:"
          ls -l "$HOME/Library/foobar2000-v2/lastfm_session.json"

      # Generate scrobble queue with dynamic timestamps to simulate recent playback
      # Each track gets a timestamp offset by 1 minute + random 10-20 seconds from the previous
      - name: Generate dynamic Last.fm queue
        run: |
          echo "üïí Generating dynamic timestamps for scrobble queue..."
          
          TEMPLATE="/tmp/queue-template.json"
          OUTPUT="$HOME/Library/foobar2000-v2/lastfm_scrobble_queue.json"
          
          echo '${{ secrets.LASTFM_SCROBBLE_QUEUE_JSON }}' > "$TEMPLATE"
          
          NOW=$(date +%s)
          echo "Current timestamp: $NOW ($(date -r $NOW))"
          
          # Generate timestamps: first track is oldest, last track is most recent
          jq --argjson now "$NOW" '
            (.queue | length) as $len |
            .queue |= (
              to_entries | map(
                .value.timestamp = ($now - (($len - 1 - .key) * 60) - (10 + (.key % 11))) |
                .value.last_attempt = 0 |
                .value.retry_count = 0
              ) | map(.value)
            )
          ' "$TEMPLATE" > "$OUTPUT"
          
          echo ""
          echo "‚úÖ Queue with dynamic timestamps generated:"
          jq -r '.queue[] | "  \(.artist) - \(.track) (timestamp: \(.timestamp))"' "$OUTPUT"
          echo ""
          echo "üìã Verification - oldest and newest tracks:"
          jq '.queue | [first, last] | .[] | {artist, track, timestamp}' "$OUTPUT"

      - name: Print environment info
        run: |
          sw_vers
          uname -a
          echo "Xcode version:"
          xcodebuild -version
          echo "Home: $HOME"

      # Run foobar2000 with the plugin and validate that:
      # 1. Plugin initializes correctly
      # 2. Session authentication works
      # 3. Queue is loaded and processed
      # 4. Scrobbling succeeds
      - name: üß™ Run foobar2000 self-test (Last.fm Scrobbler)
        run: |
          LOG_FILE="${FOOBAR_LOG_FILE}"

          echo "üöÄ Launching foobar2000 in background..."
          /Applications/foobar2000.app/Contents/MacOS/foobar2000 -i > "$LOG_FILE" 2>&1 &
          FOOBAR_PID=$!

          # Wait for foobar to initialize and process the scrobble queue
          sleep ${FOOBAR_WAIT_SECS}

          echo "üßπ Stopping foobar2000..."
          kill "$FOOBAR_PID" 2>/dev/null || pkill foobar2000 || true

          echo "::group::üìú Foobar2000 Log"
          tail -n ${FOOBAR_LOG_STRINGS} "$LOG_FILE" || cat "$LOG_FILE"
          echo "::endgroup::"

          echo "üîç Checking for expected log patterns..."
          FAILED=0

          # Helper function to check if a pattern exists in the log file
          check_pattern() {
            local label="$1"
            local pattern="$2"
            if grep -qF "$pattern" "$LOG_FILE"; then
              echo "‚úÖ $label - found"
            else
              echo "‚ùå $label - missing"
              FAILED=1
            fi
          }

          # Verify plugin initialization
          check_pattern "API init" "Last.fm: LastfmApi instance created"
          check_pattern "Session loaded" "Last.fm: Session loaded from disk"
          check_pattern "Session validated" "Last.fm: Session key validated"
          check_pattern "Authenticated" "Last.fm Scrobbler: Authenticated as"
          check_pattern "Plugin ready" "Last.fm Scrobbler: Initialized successfully"

          # Verify queue operations
          check_pattern "Queue loaded" "Last.fm: Successfully loaded 10 tracks from queue file"
          check_pattern "Queue initialized" "Last.fm: Queue initialized, 10 tracks loaded"
          check_pattern "Queue processing" "Last.fm: Processing queue with 10 tracks"
          check_pattern "Queue scrobbled" "Last.fm: Successfully scrobbled from queue"
          check_pattern "Queue processed" "Last.fm: Processed 10 tracks this cycle"
          check_pattern "Queue saved" "Last.fm: Successfully saved queue to disk"

          echo ""
          if [ "$FAILED" -eq 0 ]; then
            echo "üéâ All validation checks passed!"
          else
            echo "üî• One or more checks failed. Full log below:"
            cat "$LOG_FILE"
            exit 1
          fi

      - name: üì¶ Archive built component
        run: |
          echo "::group::üì¶ Archive Component"
          COMPONENT=$(find foobar2000/foo_mac_scrobble/build -type d -name "foo_mac_scrobble.component" | head -n 1)
          if [ -z "$COMPONENT" ]; then
            echo "‚ùå Component not found!"
            exit 1
          fi

          mkdir -p artifacts
          cp -r "$COMPONENT" artifacts/
          cd artifacts
          zip -r ../${FOOBAR_PLUGIN_ZIP_NAME} foo_mac_scrobble.component/
          cd ..
          echo "‚úÖ Archived component at: ${FOOBAR_PLUGIN_ZIP_NAME}"
          echo "::endgroup::"

      - name: üì§ Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: foo_mac_scrobble_build
          path: ${{ env.FOOBAR_PLUGIN_ZIP_NAME }}
          if-no-files-found: error

      - name: üì§ Upload build log as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build_log
          path: foobar2000/foo_mac_scrobble/build/build.log
          if-no-files-found: error

      # Upload the log file as an artifact for debugging if needed
      - name: Upload foobar2000 logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: foobar_log
          path: ${{ env.FOOBAR_LOG_FILE }}
          if-no-files-found: error
